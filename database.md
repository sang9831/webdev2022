데이터베이스 기말범위 복습
===
## 데이터베이스 생명 주기
+ 데이터베이스는 최초 사용자의 요구에 의해 구축되어 사용되다가 필요에 따라 개선 또는 다시 구축되어 사용됨
+ 데이터베이스의 생성과 운영에 관련된 특징을 데이터베이스 생명주기라고 함
1. 요구사항 수집 및 분석
    + 사용자들의 요구사항을 듣고 분석하여 데이터베이스 구축의 범위를 정하는 단계
    + 마당서점의 경우 고객, 운영자, 경영자 등 사용자의 범위와 서비스 수준을 정하는 것을 말함
2. 설계
    + 분석된 요구사항을 기초로 주요 개념과 업무 프로세스 등을 식별하고(개념적 설계), 사용하는 DBMS의 종류에 맞게 변환(논리적 설계)한 후, 데이터베이스 스키마를 도출(물리적 설계)함
3. 구현
    + 설계 단계에서 생성한 스키마를 실제 DBMS에 적용하여 테이블 및 관련 객체(뷰, 인덱스 등)를 만듦
    + 관련 소프트웨어에 설계한 데이터베이스를 적용하여 서비스를 제공할 수 있도록 프로그램을 완성
4. 운영
    + 구현된 데이터베이스를 기반으로 소프트웨어를 구축하여 서비스를 제공
5. 감시 및 개선
    + 데이터베이스 운영에 따른 시스템의 문제를 관찰하고 데이터베이스 자체의 문제점을 파악하여 개선
    + 데이터베이스가 지속적으로 운영될 수 있도록 변경 및 유지 보수를 함
---
## 데이터 모델링 과정
+ 데이터베이스 생명 주기 중 요구사항 수집 및 분석부터 설계까지의 과정
+ 요구사항 수집 및 분석 단계
    + 현실 세계의 대상 및 사용자의 요구사항을 정리하고 분석
+ 설계 단계
    + 중요 개념을 구분(개념적 모델링)
    + 각 개념을 구체화(논리적 모델링)
    + 개체, 인덱스 등을 생성(물리적 모델링)

+ 요구사항 수집 및 분석
    + 앞으로 진행 방향이 이 단계에서 결정되므로 매우 중요
    + 요구사항 수집을 위한 방법
        + 실제 문서를 수집하고 분석
        + 담당자와의 인터뷰나 설문조사를 통해 요구사항을 직접 수렴
        + 비슷한 업무를 처리하는 기존의 데이터베이스를 분석
        + 각 업무와 연관된 모든 부문을 살펴봄
+ 개념적 모델링
    + 요구사항을 수집하고 분석한 결과를 토대로 업무의 핵심적인 개념을 구분하고 전체적인 뼈대를 만드는 과정
    + 핵심적인 개념을 구분한다는 것은 개체(entity)를 추출하고 각 개체들 간의 관계(relation)를 정의하여 ER 다이어그램을 만드는 과정까지를 말함
+ 논리적 모델링
    + 개념적 모델링에서 만든 ER 다이어그램을 사용하고자 하는 DBMS에 맞게 사상하여 실제 데이터베이스로 구현하기 위한 모델을 만드는 과정
    + 논리적 모델링 과정
        + 개념적 모델링에서 추출하지 않았던 상세 속성들을 모두 추출
        + 정규화를 수행
        + 데이터의 표준화를 수행
+ 물리적 모델링
    + 작성된 논리적 모델을 실제 컴퓨터의 저장 장치에 저장하기 위한 물리적 구조를 정의하고 구현하는 과정
    + DBMS의 특성에 맞게 저장 구조를 정의하여야 데이터베이스가 최적의 성능을 낼 수 있음
    + 물리적 모델링을 할 때 트랜잭션, 저장 공간 설계 측면에서 고려할 사항
        + 응답시간을 최소화해야 함
        + 얼마나 많은 트랜잭션을 동시에 발생시킬 수 있는지 검토해야 함
        + 데이터가 저장될 공간을 효율적으로 배치해야 함
---
## ER 모델
+ ER 모델
    + 데이터 모델링 과정 중 개념적 모델링에 사용하는 모델
    + 세상의 사물을 개체와 개체 간의 관계로 표현
    + 개체는 독립적인 의미를 지니고 있는 유무형의 사람 또는 사물을 말하며, 개체의 특성을 나타내는 속성으로 식별
    + 개체끼리는 서로 관계를 가짐
    + 개체, 속성, 관계를 규명하는 것이 ER 모델의 기본
    + ER 모델은 개체와 개체 간의 관계를 ER 다이어그램이라는 표준화된 그림으로 표현함

+ 개체와 개체 타입
    + 개체는 비슷한 속성을 가진 개체 타입을 구성하며, 개체 집합으로 묶임
    + 개체 집합은 공통된 속성을 가진 개체들의 모임을 의미
    + 개체 타입은 개체 집합의 이러한 동일한 특징을 나타내는 용어
    + 개체의 특징
        + 유일한 식별자에 의해 식별이 가능함
        + 꾸준한 관리를 필요로 하는 정보임
        + 두 개 이상 영속적으로 존재함
        + 업무 프로세스에 이용됨
        + 반드시 자신의 특징을 나타내는 속성을 포함함
        + 다른 개체와 최소 한 개 이상의 관계를 맺고 있음
+ 속성
    + 속성 : 개체가 가진 성질
+ 속성의 유형
    + 더 작은 단위로 분해할 수 있는지에 따라
        + 단순 속성
            + 더 이상 분해가 불가능한 속성
        + 복합 속성
            + 독립적인 의미를 가진 속성으로 분해할 수 있는 속성
    + 속성 값의 개수에 따라
        + 단일값 속성
            + 하나의 값만 가지는 속성
        + 다중값 속성
            + 여러개의 값을 가지는 속성
    + 속성 값이 다른 속성으로부터 유도될 수 있는지에 따라
        + 저장 속성
            + 다른 속성의 영향 없이 단독으로 저장되는 속성
        + 유도 속성
            + 다른 저장 속성으로부터 유도된 속성

+ 관계와 관계 타입
    + 개체 사이의 연관성을 나타내는 개념
    + 관계 타입은 개체 타입과 개체 타입 간의 연결 가능한 관계를 정의한 것
    + 관계 집합은 관계로 연결된 집합
+ 관계 타입의 유형
    + 차수에 따른 유형
        + 1진 관계
            + 한 개의 개체가 자기 자신과 관계를 맺음
        + 2진 관계
            + 두 개의 개체가 관계를 맺음
        + 3진 관계
            + 세 개의 개체가 관계를 맺음
    + 관계 대응 수에 따른 유형
        + 일대일 관계
            + 하나의 개체가 하나의 개체에 대응
        + 일대다 관계
            + 하나의 개체가 여러 개의 개체에 대응
        + 다대일 관계
            + 여러 개체가 하나의 개체에 대응
        + 다대다 관계
            + 여러 개체가 여러 개체에 대응
---
## 이상현상
+ 잘못 설계된 테이블로 삽입, 삭제, 수정같은 데이터 조작을 하면 이상현상이 발생
+ 데이터베이스 설계가 잘못되면 SQL문의 결과가 틀리거나 원하는 결과가 나오지 않는 등의 문제 발생

+ 삭제이상 : 투플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
+ 삽입이상 : 투플 삽입 시 특정 속성에 해당하는 값이 없어 NULL 값을 입력해야 하는 현상
+ 수정이상 : 투플 수정 시 중복된 데이터의 일부만 수정되어 데이터의 불일치 문제가 일어나는 현상

---
## 함수 종속성
+ 이상현상이 발생하는 테이블을 수정하여 정상으로 만드는 과정을 정규화라고 함
+ 정규화를 하기 위해서는 먼저 테이블을 분석하여 기본키와 함수 종속성을 파악해야 함
+ 어떤 속성 A의 값을 알면 다른 속성 B의 값이 유일하게 정해지는 의존 관계를 '속성 B는 속성 A에 종속한다' 혹은 '속성 A는 속성 B를 결정한다'하고 함
+ A->B로 표기, A는 B의 결정자라고 함
+ 왼쪽 속성의 모든 값에 대하여 오른쪽 속성의 값이 유일하게 결정될 때 '함수적으로 종속한다'라고 함
+ 릴레이션의 속성 간에 함수적으로 종속하는 성질을 '함수 종속성'이라 함

+ 함수 종속성 규칙
    + 부분집합 규칙
    + 증가 규칙
    + 이행 규칙
    + 결합 규칙
    + 분해 규칙
    + 유사이행 규칙

+ 함수 종속성과 기본키
    + 릴레이션 R(K, A1, A2, A3, ~ , An)에서 K가 기본키이면, K->R이 성립, 즉 기본키는 릴레이션의 모든 속성에 대해 결정자임
    
+ 이상현상과 결정자
    + 이상현상은 기본키가 아니면서 결정자인 속성(비후보키 결정자 속성)이 있을 때 발생

---
## 정규화
+ 제 1정규형 : 관계 데이터베이스에서 릴레이션의 속성 값은 반드시 원자값이어야 함
+ 제 2정규형 : 릴레이션 R이 제 1정규형이고 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때 제 2정규형이라고 함
    + 완전 함수 종속 : A와 B가 릴레이션 R의 속성이고 A->B 종속성이 성립할 때, B가 A의 속성 전체에 함수 종속하고 부분 집합 속성에 함수 종속하지 않을 경우 완전 함수 종속이라고 함
+ 제 3정규형 : 릴레이션 R이 제 2정규형이고 기본키가 아닌 속성이 기본키에 비이행적으로 종속할 때 제 3정규형이라고 함
    + 이행적 종속 : A->B, B->C가 성립할 때 A->C가 성립되는 함수 종속성

+ BCNF 정규형 : 릴레이션 R에서 함수 종속성 X->Y가 성립할 때 모든 결정자 X가 후보키이면 BCNF 정규형이라고 함

+ 무손실 분해
    + 분해된 릴레이션 간의 관계를 유지하기 위해 분해된 릴레이션에 공통 속성을 한 개 이상 두어야 함
    + 공통 속성은 분해된 릴레이션을 다시 원래의 릴레이션으로 합성(조인)할 때 사용
    + 릴레이션 R을 릴레이션 R1과 R2로 분해할 때, R1▷◁R2=R이면 무손실 분해라고 함
    + 무손실 분해를 위한 고전은 R1∩R2->R1이나 R1∩R2->R2 중 하나를 만족해야 함

---
## 트랜잭션
+ 트랜잭션 : DBMS에서 데이터를 다루는 논리적인 작업의 단위
+ 데이터베이스에서 트랜잭션을 정의하는 이유
    + 데이터베이스에서 데이터를 다룰 때 장애가 일어아는 경우가 있음. 트랜잭션은 장애 발생 시 데이터를 복구하는 작업의 단위가 됨
    + 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때가 있음. 트랜잭션은 이 작업을 서로 분리하는 단위가 됨

+ 트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야 함
+ START TRANSACTION문과 COMMIT문을 사용하여 트랜잭션의 시작과 끝을 표시
+ 트랜잭션의 수행 과정 : 시작 -> 수행 -> 부분완료 -> 버퍼내용 기록 -> 완료

---
## 트랜잭션의 성질
+ 원자성 : 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야 함
+ 일관성 : 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 함
+ 고립성 : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 함
+ 지속성 : 수행을 성공적으로 완료한 트랜잭션은 변경한 게이터를 영구히 저장해야 함. 저장된 데이터베이스는 저장 직후 혹은 어느 때나 발생할 수 있는 정전, 장애, 오류에 영향을 받지 않아야 함

+ DBMS는 원자성, 지속성을 유지하기 위해 회복 관리자 프로그램을 작동, 일관성을 유지하기 위해 무결성 제약조건을 활용하고 동시성 제어 알고리즘을 작동, 고립성을 유지하기 위해 일관성을 유지하는 것과 마찬가지로 동시성 제어 알고리즘을 작동

---
## 동시성 제어
+ 데이터베이스는 공유를 목적으로 하기 때문에 가능한 많은 트랜잭션을 동시에 수행시켜야 함
+ 트랜잭션이 동시에 수행될 때 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능을 동시성 제어라고 함

+ 갱신손실 문제
    + 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생함
    + 데이터베이스에서 절대 발생하면 안 되는 현상
+ 락
    + 갱신손실 문제를 해결하려면 상대방 트랜잭션이 데이터를 사용하는지 여부를 알 수 있는 규칙이 필요
    + 자신이 데이터를 수정 중이라는 사실을 알리면 됨->락이란 방법 사용
    + 락은 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금 장치
    + 락을 이용하여 자신이 사용할 데이터를 잠그면 다른 트랜잭션은 잠금이 풀릴 때까지 기다려야 함
+ 락의 유형
    + 공유락(LS) : 트랜잭션이 읽기를 할 때 사용하는 락
    + 배타락(LX) : 트랜잭션이 읽기/쓰기를 할 때 사용하는 락
    + 데이터 X를 다루는 트랜잭션이 공유락과 배타락을 사용하는 규칙
        + 데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸 수 있다
        + 트랜잭션이 데이터 X를 읽기만 할 경우 LS(X)를 요청하고, 읽거나 쓰기를 할 경우 LX(X)를 요청한다
        + 다른 트랜잭션이 데이터에 LS(X)을 걸어두면, LS(X)의 요청은 허용하고 LX(X)는 허용하지 않는다
        + 다른 트랜잭션이 데이터에 LX(X)을 걸어두면, LS(X)와 LX(X) 모두 허용하지 않는다
        + 트랜잭션이 락을 허용받지 못하면 대기 상태가 된다
+ 2단계 락킹
    + 락을 걸고 해제하는 시점에 제한을 두지 않으면 두 개의 트랜잭션이 동시에 실행될 때 데이터의 일관성이 깨질 수 있음 -> 2단계 라킹 기법 사용
    + 확장단계 : 트랜잭션이 필요한 락을 획득하는 단계로, 이 단계에서는 이미 획득한 락을 해제하지 않는다
    + 수축단계 : 트랜잭션이 락을 해제하는 단계로, 이 단계에서는 새로운 락을 획득하지 않는다
    + 데드락 : 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청해 무한 대기 상태에 빠지는 현상 -> 일반적으로 데드락이 발생하면 DBMS가 트랜잭션1 혹은 트랜잭션2의 작업 중 하나를 강제중지시킴

---
## 트랜잭션 고립 수준

+ 트랜잭션 동시 실행 문제
    + 오손 읽기
        + 읽기 작업을 하는 트랜잭션1이 쓰기 작업을 하는 트랜잭션2가 작업한 중간 데이터를 읽기 때문에 생기는 문제
        + 작업 중인 트랜잭션2가 어떤 이유로 작업을 철회(ROLLBACK)할 경우 트랜잭션1은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출
    + 반복불가능 읽기
        + 트랜잭션1이 데이터를 읽고 트랜잭션2가 데이터를 쓰고(갱신, UPDATE), 트랜잭션1이 다시 한 번 데이터를 읽을 때 생기는 문제
        + 트랜잭션1이 읽기 작업을 다시 한 번 반복할 경우 이전의 결과가 반복되지 않는 현상
    + 유령데이터 읽기
        + 트랜잭션1이 데이터를 읽고 트랜잭션2가 데이터를 쓰고(삽입, INSERT), 트랜잭션1이 다시 한 번 데이터를 읽을 때 생기는 문제
        + 트랜잭션1이 읽기 작업을 다시 한 번 반복할 경우 이전에 없던 데이터(유령 데이터)가 나타나는 현상

+ 트랜잭션 고립 수준 명령어
    + DBMS에서 제공하는 트랜잭션을 동시에 실행시키면서 락보다 좀 더 완화된 방법으로 문제를 해결하는 명령어
    + READ UNCOMMITTED : 오손 읽기-가능, 반복불가능 읽기-가능, 유령데이터 읽기-가능
    + READ COMMITTED : 오손 읽기-불가능, 반복불가능 읽기-가능, 유령데이터 읽기-가능
    + REPEATABLE READ : 오손 읽기-불가능, 반복불가능 읽기-불가능, 유령데이터 읽기-가능
    + SERIALIZABLE : 오손 읽기-불가능, 반복불가능 읽기-불가능, 유령데이터 읽기-불가능

    + 고립 수준이 높아질수록 제한히 심해지고 데이터의 동시성이 낮아짐
---
## 회복
+ 데이터베이스 시스템에서 발생할 수 있는 장애의 유형
    + 시스템 충돌
    + 미디어 장애
    + 응용 소프트웨어 오류
    + 자연재해
    + 부주의 혹은 태업

+ 트랜잭션과 회복
    + 트랜잭션은 데이터베이스 회복의 단위
    + DBMS의 회복 관리자는 트랜잭션의 ACID 성질 중 원자성과 지속성을 보장하여 장애로부터 데이터베이스를 보호
    + 장애가 발생하면 로그의 내용을 참조하여 트랜잭션의 변경 내용을 모두 반영하거나 아니면 아예 반영하지 않는 방법으로 원자성, 지속성을 보장
    + 트랜잭션이 일단 COMMIT한 내용은 로그를 이용하여 반드시 데이터베이스에 기록
+ 로그 파일
    + DBMS는 트랜잭션이 수행 중이거나 수행이 종료된 후 발생하는 데이터베이스 손실을 방지하기 위해 트랜잭션의 데이터베이스 기록을 추적하는 로그 파일을 사용
    + 로그의 구조 : <트랜잭션번호, 로그 타입, 데이터 항목 이름, 수정 전 값, 수정 후 값>
    + 로그 타입 : START, INSERT, UPDATE, DELETE, ABORT, COMMIT

+ 로그 파일을 이용한 회복
    + 트랜잭션의 재실행(REDO)
        + 장애가 발생한 후 시스템을 다시 가동을 했을 때 로그 파일에 트랜잭션의 시작(START)과 종료(COMMIT)가 있는 경우
        + COMMIT연산이 로그에 있다 -> 트랜잭션이 모두 완료되었음
        + 변경 내용이 버퍼에서 데이터베이스에 기록되지 않았을 가능성이 있음
        + 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에 다시 기록하는 과정 -> REDO
    + 트랜잭션의 취소(UNDO)
        + 장애가 발생한 후 시스템을 다시 가동을 했을 때 로그 파일에 트랜잭션의 시작(START)만 있고 종료(COMMIT)가 없는 경우
        + COMMIT연산이 로그에 없다 -> 트랜잭션이 완료되지 못했음
        + 완료하지 못했지만 버퍼의 변경 내용이 데이터베이스에 기록되어 있을 가능성이 있음
        + 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에서 원상복구시키는 과정 -> UNDO

    + 즉시갱신
        + '버퍼->로그 파일', '버퍼->데이터베이스' 작업이 부분완료 전에 동시에 진행될 수 있으며, 부분완료 전에 버퍼의 갱신 데이터는 로그에 기록이 진행이 된 상태이며 부분완료 전에 버퍼의 일부 내용이 실제 데이터베이스에 반영이 될 수 있음
    + 지연갱신
        + '버퍼->로그 파일'이 모두 끝난 후 부분완료를 하고 이후 '버퍼-> 데이터베이스' 작업을 진행하는 방법
        + 부분완료 전에는 갱신 내용이 실제 데이터베이스에 반영이 되지 않는 상태
        + 지연갱신 방법을 사용하면 데이터베이스에 반영하는 작업은 지연되지만, 장애가 발생할 경우 로그에 START만 나타나는 트랜잭션은 취소(UNDO) 작업을 할 필요가 없는 장접이 있음

+ 체크포인트를 이용한 회복
    + 로그를 이용한 회복은 시스템에 장애가 일어났을 때 어느 시점까지 되돌아가야 하는지 알 수 없음
    + 체크포인트 : 회복 시 많은 양의 로그를 검색하고 갱신하는 시간을 줄이기 위하여 몇 십 분 단위로 데이터베이스와 트랜잭션 로그 파일을 동기화한 후 동기화한 시점을 로그 파일에 기록해두는 방법 혹은 그 시점
    + 체크포인트 시점에 하는 작업
        + 주기억장치의 로그 레코드를 모두 하드디스크의 로그 파일에 저장
        + 버퍼에 있는 변경된 내용을 하드디스크의 데이터베이스에 저장(즉시갱신 경우)
        + 체크포인트를 로그 파일에 표시
    
    + 체크포인트 이전에 COMMIT 기록이 있는 트랜잭션의 경우
        + 아무 작업이 필요 없음->로그에 체크포인트가 나타나는 시점은 이미 변경 내용이 체크포인트에 의하여 데이터베이스에 모두 기록된 후이기 때문(즉시갱신, 지연갱신)
    + 체크포인트 이후에 COMMIT 기록이 있는 트랜잭션의 경우
        + REDO(T)를 진행->체크포인트 이후에 변경 내용이 데이터베이스에 반영되지 않았을 가능성이 있으므로
    + 체크포인트 이후에 COMMIT 기록이 없는 트랜잭션의 경우
        + 즉시갱신-UNDO(T) -> 버퍼의 내용이 반영됐을 수도 있기 때문에 원상복구 시켜야함
        + 지연갱신-아무 작업 필요 없음 -> 지연갱신 방법은 COMMIT 이전에는 버퍼의 내용을 데이터베이스에 반영하지 않기 때문

---
## 데이터베이스 보안과 관리
+ 데이터베이스 관리 업무
    + 서비스 관리
    + 점검 및 모니터링
    + 장애 대처
    + 백업과 복원
    + 사용자 관리 및 권한 관리
    + 시스템 데이터베이스 관리
    + 사용자 데이터베이스 관리
    + 데이터베이스 저장 공간 관리
    + 인덱스 관리
    
---
## 부속질의
부속질의 : 하나의 SQL문 안에 다른 SQL문이 중첩된 질의  
+ 조인을 사용할 경우 : Customer 테이블과 Orders 테이블의 고객번호로 조인한 후 필요한 데이터를 추출
+ 부속질의를 사용할 경우 : Customer 테이블에서 박지성 고객의 고객번호를 찾고, 찾은 고객번호를 바탕으로 Orders 테이블에서 확인

두 테이블을 연관시킬 때 조인을 선택할지 부속질의를 선택할지 여부는 데이터의 형태와 양에 따라 다름.  
일반적으로 데이터가 대량일 경우 데이터를 모두 합쳐서 연산하는 조인 보다 필요한 데이터만 찾아서 공급해주는 부속질의의 성능이 더 좋음.

부속질의의 종류
+ 스칼라 부속질의
    + 위치 : select절
+ 인라인 뷰
    + 위치 : from절
+ 중첩질의
    + 위치 : where절
